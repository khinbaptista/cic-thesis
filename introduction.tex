\chapter{Introduction}

Shader programming is an essential part of modern computer graphics. However, in order to write her/his first shader program, one is often faced with the need to write an entire host application that will supply data for the shader. This includes establishing associations between variables from the host program and from the shader, loading polygonal models, setting parameters, initializing textures, etc.
All this can be quite discouraging for a novice, deviating one's attention from actual shader programming to the development of application infrastructure.

To make it easier for newcomers, we have built an application that provides a complete environment for shader programming. With this tool, one will be able to write shaders without having to worry about such infrastructure details. By being able to focus on the shaders themselves and get results faster, we hope to encourage more students to learn computer graphics. Developing such a tool also had another important personal goal: serve as an opportunity for learning Vulkan, a modern graphics API.

Our application allows students to easily prototype shaders using an integrated source code editor, and to view the results in real time in the visualization window, which can include any objects the user wants to add, including custom meshes that can be imported. While implementing this tool, we were able to understand the inner workings of Vulkan, an API which is growing fast and becoming more present in the industry of computer graphics.

This thesis is organized as follows: Chapter 2 presents the reader with a base knowledge about computer graphics and how the modern graphics applications perform their functions, as well as introduces Godot Engine, the tool used to create our application. Chapter 3 introduces important details of the Vulkan API and how it differs from OpenGL. Chapter 4 describes the methods applied in the implementation of our tool, the architecture of our application and how to use it from a user perspective. Chapter 5 presents the results we were able to obtain using our solution. Chapter 6 concludes this work, presenting our view of the tool developed. Chapter 7 discusses how our application could be improved in the future.

\section{Related work}
As we mentioned, many attempts were made to create development environments for shaders.

\textbf{RenderMonkey}, developed by AMD, aimed to provide tools for both programmers and artists. It featured a complete shader source editor and preview window, but also a workspace specific for artists, where much of the shader programming was hidden from the user, widgets used to adjust parameter values. It presented support for HLSL, GLSL and GLES shading languages \cite{rendermonkey}. The latest version of the software was released in 2008 \cite{rendermonkey_release_notes} and AMD's website no longer displays any information about the software or that it ever existed.

\textbf{FX Composer}, developed by NVIDIA, featured an integrated source code editor, a scene visualizer which could use DirectX 10, DirectX 9 or OpenGL, widgets for editing parameters, particle systems, material manager, material preview and much more \cite{fxcomposer}. The software has not been updated since 2008 \cite{fxcomposer_release_notes}, presenting many usability issues and instability, such as debug messages pointing to errors that were not from the user code but from the software architecture. This is part of the motivation to create this work.

\textbf{Shadertoy} is an online resource which allows users to write only fragment shaders to create effects. \textbf{Shdr} is another online resource to write both vertex and fragment shaders, but the user is not allowed to define uniform variables (parameters to change the results generated by the shaders). The lack of features on both applications prevents the user from creating a large variety of effects.

\textbf{ShaderLabFramework} \cite{toisoul} is a tool created for the undergraduate Computer Graphics course in the Imperial College London, UK, and was tailored to their course syllabus. It implements a two-pass rendering pipeline structure, allowing users to render to texture and applying post-processing effects. This application was implemented in C++ using the Qt framework for user interface, and uses OpenGL to render the visualization scene.
