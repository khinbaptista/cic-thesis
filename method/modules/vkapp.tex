\subsection{Vulkan Application Module}
This module is responsible for creating the objects which are global to the application. First, it creates the GLFW window that we will use to render the Vulkan scene. It also registers the mouse button callback and the mouse motion callback, which will be called by the GLFW library so that our application can react to user interaction, mostly to move the camera.

To create the Vulkan instance, the extensions our application will enable are those listed by `glfwGetRequiredInstanceExtensions', a convenient method provided by GLFW to query the required extensions for our window to work properly. We do not need any other instance extensions.

With a list of the available devices, their features and queue families properties, we can select a `VkPhysicalDevice' and create a logical device to interface with it. For a rendering application like ours, we need a physical device which presents a queue family able to render graphics, and another able to do presentation (displaying images in the window). These queues could be the same, if the physical device presents a single queue family with both graphics and presentation capabilities.

Creating the window surface is easy thanks to GLFW, which enables the required extensions with `glfwGetRequiredInstanceExtensions', and provides a simple `glfwCreateWindowSurface' function which simply returns a surface appropriate for the current platform.

For swap chain creation, we select the mailbox present mode if available; if not, we use the FIFO, which is the only setting guaranteed to be supported. We also create the depth resources, render pass and framebuffers. After the command pool is created, our application can allocate command buffers from it.

For the drawing commands, we will have to issue a command to bind the correct framebuffer object and, since we have more than one framebuffer (one for each image in the swap chain), we also have to allocate multiple command buffers, and record the drawing operations in all of them.

Whenever a new object is added to the scene, or a material is assigned to an object, the drawing operations must be re-recorded. To record the drawing commands, we will begin the command buffer with the flag "command buffer usage: simultaneous use" set, which allows our application to request execution of the command buffer before a previous execution has finished. With the command buffer initialized (after a command buffer begin function call), we begin a render pass, which will refer to the render pass object we created beforehand, the framebuffer which will be used, and the clear values used for the color and depth attachments. Then, the render pass can begin (`vkCmdBeginRenderPass' function). The drawing commands are then recorded for each geometry in the scene. After the commands are recorded, the render pass must be ended, as well as the command buffer itself.

\subsubsection{Application Loop}
Every frame, there is a sequence of commands we have to execute. Since this module manages the Vulkan window, we first need to handle any input events from the window. We also poll for certain keyboard events to move the camera. We do this instead of registering a callback with GLFW because keyboard events have delay and repeat configurations, which makes the camera movement stiff and unpleasant; the poll approach allows us to check keys' status every frame, creating a smooth camera movement.

After our application handles the input events, certain variables are updated to be passed to the shaders as uniform variables. These include the camera view and projection matrices and their inverted counterparts. These variables must be passed to all the objects rendered in the scene so that their uniform buffers will be up to date for rendering.

Vulkan rendering is comprised of two different steps: first, we have to render to one of the swap chain images, and then we have to display it in the window surface. To begin rendering, we have to acquire the next image available from the swap chain. Since the command executions happen in the GPU, rendering is asynchronous, which requires us to use a semaphore which will be signaled when there is an image available for rendering. We then use the graphics queue to execute the command buffer of the image acquired from the swap chain.

After rendering, we will use the present queue to display the image on the window surface. Again, rendering happens in the GPU and our application must make sure the image is available for presentation, so we have to use a second semaphore, signaled when rendering is finished in the graphics queue, to which the present queue will wait before executing.

\subsubsection{Single Time Commands}
Certain common operations are executed in different parts of code, like copying buffer data, transferring buffer data to image and transitioning image layout. These operations, in Vulkan, must be executed in a queue by a command buffer. The commands must be recorded in advance, and then the command buffer can be executed. These operations, however, are not part of the render loop; they are required to take place during initialization of resources. For this end, since command buffers must be allocated from a command pool which is managed by the Vulkan application module, there are commands to setup a command buffer to perform any of these commands, and then to submit them to the graphics queue for execution before they are freed.

\subsubsection{Cleaning Up}
During cleanup, a lot of Vulkan resources have to be appropriately freed and destroyed, respecting their dependencies. First, the application must wait for the device to become idle, i.e., there are not any pending operations to be executed. Then, resources can be freed. Our application begins destroying the depth image view, depth image, and then freeing the device memory used by the depth image. Next, the semaphores used to signal when an image is ready and when a presentation is done are destroyed. Then, the command pool is destroyed, which automatically destroys the command buffers allocated from it. Next, the framebuffers are destroyed, followed by the render pass object and image views of the swap chain images. The swap chain is then destroyed as well, followed by the debug callback (when the application is compiled in debug mode), the window surface and finally the Vulkan instance. Last, the GLFW window is destroyed before the application is terminated.
