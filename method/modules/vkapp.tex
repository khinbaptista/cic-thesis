\subsection{Vulkan Application Module}
Vulkan is a low-level API and, as such, requires developers to setup a large amount of objects and configurations before displaying anything on screen. This module is responsible for creating these objects required for rendering.

The first thing this module does, however, is create the GLFW window that we will use to render the Vulkan scene. It also registers the mouse button callback and the mouse motion callback, which will be called by the GLFW library so that our application can react to user interaction, mostly to move the camera, in our case.

\subsubsection{Vulkan Instance}
There is no global state in Vulkan and all per-application state is stored in a 'VkInstance' object. Creating a 'VkInstance' object initializes the Vulkan library and allows the application to pass information about itself to the implementation \cite{vulkan_docs}. Applications can even define and manage multiple instances if they so desire.

In order to initialize a Vulkan instance object, we first need to create a 'VkApplicationInfo' structure object, which will describe our application for the driver. This structure hold the name and version of the application, and also the name and version of the engine used. This data is technically optional, but it may provide some useful information to the driver to optimize for our specific application, for example because it uses a well-known graphics engine with certain special behavior \cite{vulkan_tutorial}. Unlike the 'VkApplicationInfo', the 'VkInstanceCreateInfo' structure object is not optional. It describes the instance extensions and debug layers we want to enable in our application. To make sure our application can be executed, we can check the available extensions with the function 'vkEnumerateInstanceExtensionProperties' to compare against our required extensions. In our application, we are using GLFW for window management, which provides the 'glfwGetRequiredInstanceExtensions' function \cite{glfw_vulkan} to query the required functions for surface creation on any platform supported by the library.

During the Vulkan instance object creation we can also specify validation layers to be enabled. Available validation layers can be queried with the 'vkEnumerateInstanceLayerPropertie's function. The Vulkan SDK provides a standard validation layer, "VK\_LAYER\_LUNARG\_standard\_validation", which implicitly enables a range of useful diagnostic layers. In order to receive the debug messages from the validation layers, however, the application must also enable the "VK\_EXT\_debug\_report" extension, which will allow the developer to setup a callback function that will be called whenever a debug message is issued by the validation layers. To setup the debug callback function, the developer has to get a pointer to the 'vkCreateDebugReportCallbackEXT', which is an extension function and therefore not included in the base API, using the 'vkGetInstanceProcAddr' function.

\subsubsection{Physical Device}
The function 'vkEnumeratePhysicalDevices' returns a list of available Vulkan devices installed in the system. Basic device properties like the name, type and supported Vulkan version can be queried using 'vkGetPhysicalDeviceProperties'. The support for optional features like texture compression, 64 bit floats and multi viewport rendering can be queried using 'vkGetPhysicalDeviceFeatures'. Device features must be enabled before they are used by the application.

Almost every operation in Vulkan, from drawing to uploading textures, requires commands to be submitted to a queue. A queue belongs to a \emph{queue family}, and each queue family supports certain types of commands. For a rendering application like ours, we need a queue able to render graphics, and another queue for presentation (displaying images in the window). These queues could be the same, if the physical device presents a single queue with both graphics and presentation capabilities. To query queue families, there is a 'vkGetPhysicalDeviceQueueFamilyProperties' function.

With a list of the available devices, their features and queue families, we can select a \texttt{VkPhysicalDevice} and create a logical device to interface with it.

\subsubsection{Device}
The logical device creation process is similar to the instance creation process and describes the features we want to use in our application. We also need to specify which queues to create from the queue families that are available. 

The function \texttt{vkCreateDevice} takes the physical device we selected and a \texttt{VkDeviceCreateInfo} object as arguments. The latter describes which physical device features we want to enable from our selected physical device. We must also specify the queues we want to create, indicating the queue family index and amount of queues we want to create from each family. After the device is created, the application can call the \texttt{vkGetDeviceQueue} function to get the \texttt{VkQueue} objects to which commands will be passed into.

\subsubsection{Window Surface}
In order to display images, the Vulkan API must interface with the platform specific window system. Also, since Vulkan is also a compute API, this functionality is not in the core API, but is part of the "\texttt{VK\_KHR\_surface}". Window systems also vary for each platform so, in order to create the proper surface object, we also need to enable the platform surface extension ("\texttt{VK\_KHR\_win32\_surface}" for Windows, for example). Luckily, GLFW enables the required extensions with \texttt{glfwGetRequiredInstanceExtensions}, and provides a simple \texttt{glfwCreateWindowSurface} function which simply returns a surface appropriate for the current platform.

\subsubsection{Swap Chain}
Unlike OpenGL, Vulkan does not have the concept of a "default framebuffer", hence it requires a structure to own the buffers where images will be rendered before they are displayed on the screen. This is the swap chain, and it must be explicitly created in Vulkan. Creating a swap chain object requires the "\texttt{VK\_KHR\_swapchain}" device extension enabled. The swap chain is essentially a queue of images that are waiting to be presented on the screen.

Each physical device provides different capabilities in its swap chain. These include the maximum number of images the swap chain can hold, the pixel formats supported and presentation modes. The presentation modes, according to \cite{vulkan_tutorial}, are:
\begin{itemize}
    \item \texttt{VK\_PRESENT\_MODE\_IMMEDIATE\_KHR}: ages submitted by your application are transferred to the screen right away, which may result in tearing;
    \item \texttt{VK\_PRESENT\_MODE\_FIFO\_KHR}: The swap chain is a queue where the display takes an image from the front of the queue when the display is refreshed and the program inserts rendered images at the back of the queue. If the queue is full then the program has to wait. This is most similar to vertical sync as found in modern games. This is the only mode that is guaranteed to be supported;
    \item \texttt{VK\_PRESENT\_MODE\_FIFO\_RELAXED\_KHR}: This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank. Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing;
    \item \texttt{VK\_PRESENT\_MODE\_MAILBOX\_KHR}: This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones. This mode can be used to implement triple buffering, which allows you to avoid tearing with significantly less latency issues than standard vertical sync that uses double buffering.
\end{itemize}

In our application, we select the mailbox present mode if available; if not, we use the FIFO, which is the only setting guaranteed to be supported.

\subsubsection{Depth Resources}
In our application, we want to use depth buffer in order to correctly display the objects in the scene. In Vulkan, the depth buffer is an image object which the programmer has to create manually. Special formats are defined by the Vulkan API for depth images. Device memory must be allocated for the image and bound to it, and an image view also needs to be created. The image must also be transitioned to a layout optimal for depth attachment before it can be used as depth buffer.

\subsubsection{Render Pass}
A render pass represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses \cite{vulkan_docs}. In our application, we want to write to a color attachment, and we also want to use depth attachment for Z-buffer.

\subsubsection{Framebuffer}
The attachments specified in the render pass creation are bound into a framebuffer object. This object references all the image view objects that represent the attachments in the render pass. Since the swap chain has many different images (and image views), our application also has to create a framebuffer for each image view of the swap chain.

\subsubsection{Command Buffers}
In Vulkan, operations like drawing and memory transfers are not executed with functions. Instead, the commands are recorded in command buffers, which are then submitted to a queue for execution. The reasoning behind this is that recording drawing commands can be done in advance and in multiple threads, and during execution the application only has to tell the API to execute the commands already recorded, reducing CPU usage.

Before creating command buffers, the application has to create a command pool. Command pools manage the memory used to store the buffers that will be allocated from the pool. Command pools are created to execute commands on a single queue family, that is, command buffers allocated from a pool cannot simply execute any command, because the commands will be executed by a queue family which may not support the operations.

After the command pool is created, our application can allocate command buffers from it. For the drawing commands, we'll have to issue a command to bind the correct framebuffer object and, since we have more than one framebuffer (one for each image in the swap chain), we also have to allocate multiple command buffers, and record the drawing operations in all of them.

To record the drawing commands, we'll begin the command buffer with the flag "VK\_COMMAND\_BUFFER\_USAGE\_SIMULTANEOUS\_USE\_BIT" set, which allows our application to request execution of the command buffer before a previous execution has finished. With the command buffer initialized (after a command buffer begin function call), we begin a render pass, which will refer to the render pass object we created beforehand, the framebuffer which will be used, and the clear values used for the color and depth attachments. Then, the render pass can begin (vkCmdBeginRenderPass function). The drawing commands are then recorded for each geometry in the scene:

\begin{itemize}
    \item \texttt{VkCmdBindPipeline}: Binds the graphics pipeline of the material applied to the object;
    \item \texttt{VkCmdBindVertexBuffer}: Binds the vertex buffer of the object, which contains the vertex attributes;
    \item \texttt{VkCmdBindDescriptorSets}: Binds the descriptor set which contains the uniform variables data;
    \item \texttt{VkCmdBindIndexBuffer}: If the object presents index data, binds the buffer containing the indices;
    \item \texttt{VkCmdDrawIndexed}: Draw the object using the index buffer;
    \item \texttt{VkCmdDraw}: Draw object without indices.
\end{itemize}

After the commands are recorded, the render pass must be ended, as well as the command buffer itself.

Since, in our application, the user may create new objects at execution time, all drawing commands for all command buffers must be re-recorded whenever a new object is created. The same applies for when the user sets a different material to an object, which will change the data loaded in the vertex buffer and descriptor set used to draw the object.

\subsubsection{Application Loop}
Every frame, there is a sequence of commands we have to execute. Since this module manages the Vulkan window, we first need to handle any input events from the window. We also poll for certain keyboard events to move the camera. We do this instead of registering a callback with GLFW because keyboard events have delay and repeat configurations, which makes the camera movement stiff and unpleasant; the poll approach allows us to check keys' status every frame, creating a smooth camera movement.

After our application handles the input events, certain variables are updated to be passed to the shaders as uniform variables. These include the camera view and projection matrices and their inverted counterparts. These variables must be passed to all the objects rendered in the scene so that their uniform buffers will be up to date for rendering.

Vulkan rendering is comprised of two different steps: first, we have to render to one of the swap chain images, and then we have to display it in the window surface.

To begin rendering, we have to acquire the next image available from the swap chain. Since the command executions happen in the GPU, rendering is asynchronous, which requires us to use a semaphore which will be signaled when there is an image available for rendering. We then use the graphics queue to execute the command buffer of the image acquired from the swap chain.

After rendering, we will use the present queue to display the image on the window surface. Again, rendering happens in the GPU and our application must make sure the image is available for presentation, so we have to use a second semaphore, signaled when rendering is finished in the graphics queue, to which the present queue will wait before executing.

\subsubsection{Single Time Commands}
Certain common operations are executed in different parts of code, like copying buffer data, transferring buffer data to image and transitioning image layout. These operations, in Vulkan, must be executed in a queue by a command buffer. The commands must be recorded in advance, and then the command buffer can be executed. These operations, however, are not part of the render loop; they are required to take place during initialization of resources. For this end, since command buffers must be allocated from a command pool which is managed by the Vulkan application module, there are commands to setup a command buffer to perform any of these commands, and then to submit them to the graphics queue for execution before they are freed.

\subsubsection{Cleaning Up}
During cleanup, a lot of Vulkan resources have to be appropriately freed and destroyed, respecting their dependencies. First, the application must wait for the device to become idle, i.e., there are not any pending operations to be executed. Then, resources can be freed. Our application begins destroying the depth image view, depth image, and then freeing the device memory used by the depth image. Next, the semaphores used to signal when an image is ready and when a presentation is done are destroyed. Then, the command pool is destroyed, which automatically destroys the command buffers allocated from it. Next, the framebuffers are destroyed, followed by the render pass object and image views of the swap chain images. The swap chain is then destroyed as well, followed by the debug callback (when the application is compiled in debug mode), the window surface and finally the Vulkan instance. Last, the GLFW window is destroyed before the application is terminated.
