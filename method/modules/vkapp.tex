\subsection{Vulkan Application Module}
Vulkan is a low-level API and, as such, requires developers to setup a large amount of objects and configurations before displaying anything on screen. This module is responsible for creating these objects required for rendering.

\subsubsection{Vulkan Instance}
There is no global state in Vulkan and all per-application state is stored in a VkInstance object. Creating a VkInstance object initializes the Vulkan library and allows the application to pass information about itself to the implementation \cite{vulkan_docs}. Applications can even define and manage multiple instances if they so desire.

In order to initialize a Vulkan instance object, we first need to create a VkApplicationInfo structure object, which will describe our application for the driver. This structure hold the name and version of the application, and also the name and version of the engine used. This data is technically optional, but it may provide some useful information to the driver to optimize for our specific application, for example because it uses a well-known graphics engine with certain special behavior \cite{vulkan_tutorial}. Unlike the VkApplicationInfo, the VkInstanceCreateInfo structure object is not optional. It describes the instance extensions and debug layers we want to enable in our application. To make sure our application can be executed, we can check the available extensions with the function vkEnumerateInstanceExtensionProperties to compare against our required extensions. In our application, we are using GLFW for window management, which provides the glfwGetRequiredInstanceExtensions function \cite{glfw_vulkan} to query the required functions for surface creation on any platform supported by the library.

During the Vulkan instance object creation we can also specify validation layers to be enabled. Available validation layers can be queried with the vkEnumerateInstanceLayerProperties function. The Vulkan SDK provides a standard validation layer, "VK\_LAYER\_LUNARG\_standard\_validation", which implicitly enables a range of useful diagnostic layers. In order to receive the debug messages from the validation layers, however, the application must also enable the "VK\_EXT\_debug\_report" extension, which will allow the developer to setup a callback function that will be called whenever a debug message is issued by the validation layers. To setup the debug callback function, the developer has to get a pointer to the vkCreateDebugReportCallbackEXT, which is an extension function and therefore not included in the base API, using the vkGetInstanceProcAddr function.

\subsubsection{Physical Device}
The function vkEnumeratePhysicalDevices returns a list of available Vulkan devices installed in the system. Basic device properties like the name, type and supported Vulkan version can be queried using vkGetPhysicalDeviceProperties. The support for optional features like texture compression, 64 bit floats and multi viewport rendering can be queried using vkGetPhysicalDeviceFeatures. Device features must be enabled before they are used by the application.

Almost every operation in Vulkan, from drawing to uploading textures, requires commands to be submitted to a queue. A queue belongs to a \emph{queue family}, and each queue family supports certain types of commands. For a rendering application like ours, we need a queue able to render graphics, and another queue for presentation (displaying images in the window). These queues could be the same, if the physical device presents a single queue with both graphics and presentation capabilities. To query queue families, there is a vkGetPhysicalDeviceQueueFamilyProperties function.

With a list of the available devices, their features and queue families, we can select a VkPhysicalDevice and create a logical device to interface with it.

\subsubsection{Device}
The logical device creation process is similar to the instance creation process and describes the features we want to use in our application. We also need to specify which queues to create from the queue families that are available. 

The function vkCreateDevice takes the physical device we selected and a VkDeviceCreateInfo object as arguments. The latter describes which physical device features we want to enable from our selected physical device. We must also specify the queues we want to create, indicating the queue family index and amount of queues we want to create from each family. After the device is created, the application can call the vkGetDeviceQueue function to get the VkQueue objects to which commands will be passed into.

\subsubsection{Window Surface}
In order to display images, the Vulkan API must interface withb the platform specific window system. Also, since Vulkan is also a compute API, this functionality is not in the core API, but is part of the "VK\_KHR\_surface". Window systems also vary for each platform so, in order to create the proper surface object, we also need to enable the platform surface extension ("VK\_KHR\_win32\_surface" for Windows, for example). Luckily, GLFW enables the required extensions with glfwGetRequiredInstanceExtensions, and provides a simple glfwCreateWindowSurface function which simply returns a surface appropriate for the current platform.

\subsubsection{Swap Chain}
Unlike OpenGL, Vulkan does not have the concept of a "default framebuffer", hence it requires a structure to own the buffers where images will be rendered before they are displayed on the screen. This is the swap chain, and it must be explicitly created in Vulkan. Creating a swap chain object requires the "VK\_KHR\_swapchain" device extension enabled. The swap chain is essentially a queue of images that are waiting to be prensented on the screen.

Each physical device provides different capabilities in its swap chain. These include tha maximum number of images the swap chain can hold, the pixel formats supported and presentation modes. The presentation modes, according to \cite{vulkan_tutorial}, are:
\begin{itemize}
    \item VK\_PRESENT\_MODE\_IMMEDIATE\_KHR: ages submitted by your application are transferred to the screen right away, which may result in tearing;
    \item VK\_PRESENT\_MODE\_FIFO\_KHR: The swap chain is a queue where the display takes an image from the front of the queue when the display is refreshed and the program inserts rendered images at the back of the queue. If the queue is full then the program has to wait. This is most similar to vertical sync as found in modern games. This is the only mode that is guaranteed to be supported;
    \item VK\_PRESENT\_MODE\_FIFO\_RELAXED\_KHR: This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank. Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing;
    \item VK\_PRESENT\_MODE\_MAILBOX\_KHR: This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones. This mode can be used to implement triple buffering, which allows you to avoid tearing with significantly less latency issues than standard vertical sync that uses double buffering.
\end{itemize}

In our application, we select the mailbox present mode if available; if not, we use the FIFO, which is the only one guaranteed to be supported.

